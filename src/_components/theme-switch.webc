<form id="theme-switch" webc:root="override">
  <fieldset class="theme-switch" role="radiogroup">
    <legend class="visually-hidden">Select a theme</legend>
    <div class="container">
      <div aria-hidden="true">THEME</div>
      <div>
        <div class="labels" aria-hidden="true">
          <div>1</div>
          <div>2</div>
          <div>3</div>
        </div>
        <div class="track">
          <input type="radio" name="theme" id="dark" value="dark" aria-label="dark theme" checked>
          <input type="radio" name="theme" id="light" value="light" aria-label="light theme">
          <input type="radio" name="theme" id="purple" value="purple" aria-label="purple theme">
          <svg viewBox="0 0 16 16" width="16" height="16" fill="none" aria-hidden="true" focusable="false">
            <circle cx="8" cy="8" r="8" />
          </svg>
        </div>
      </div>
    </div>
  </fieldset>
</form>

<style>
  .theme-switch {
    border: none;
    padding: 0;
    margin: 0;
    font-size: var(--text-s);

    & .container {
      display: flex;
      gap: 26px;
      align-items: end;

      & > :first-child {
        margin-bottom: 5px;
        letter-spacing: var(--tracking-wide);
      }
    }

    & .labels {
      display: flex;
      justify-content: center;
      text-align: center;
      margin-bottom: 5px;

      & > * { width: 12px; }
      & > :nth-child(1) { margin-right: 11px; }
      & > :nth-child(2) { margin-right: 10px; }
    }

    & .track {
      border-radius: 13px;
      display: flex;
      background-color: var(--color-switch-track, var(--color-ebony-clay));
      position: relative;

      & > :nth-child(1) { margin-right: -3px; }
      & > :nth-child(2) { margin-right: -4px; }
    }

    & input[type="radio"] {
      width: 26px;
      height: 26px;
      margin: 0;
      opacity: 0;
      cursor: pointer;

      /* send the selected radio button behind the switch track to put the handle on top */
      &:checked { z-index: -1; }

      & ~ svg {
        margin: 5px;
        border-radius: 9999em;
        fill: var(--color-switch-handle, var(--color-persian-red));
        position: absolute;
        transition: transform 0.3s ease;
        transform: translateX(var(--handle-position));
        cursor: pointer;

        &:hover {
          fill: var(--color-switch-handle-hover, var(--color-bittersweet));
        }
      }

      &:focus-visible ~ svg {
        outline: var(--fluid-6-9) double black;
        box-shadow: 0 0 0 var(--fluid-4-6) white;
      }

      &:nth-child(2):checked ~ svg {
        --handle-position: 23px;
      }

      &:nth-child(3):checked ~ svg {
        --handle-position: 45px;
      }
    }
  }
</style>

<script>
  /** @typedef {'light'|'dark'|'purple'} Theme */

  /** @type {Theme} theme - The state that holds the current theme */
  let theme
  /** @type {HTMLFormElement} themeSwitch - The DOM element that allows users to change the current theme */
  let themeSwitch

  /**
   * Gets the theme preference from the local storage (if set). Otherwise,
   * returns 'light' or 'dark' depending on the `prefers-color-scheme` value
   *
   * @returns {Theme}
   */
  function getThemePreference(key = 'theme-preference') {
    if (localStorage.getItem(key)) {
      return localStorage.getItem(key)
    } else {
      return window.matchMedia('(prefers-color-scheme: light)').matches
        ? 'light'
        : 'dark'
    }
  }

  /**
   * Updates the DOM to reflect the theme change
   */
  function reflectThemeChange() {
    document.documentElement.setAttribute('data-theme', theme)

    if (document.readyState === 'loading') return

    if (!themeSwitch) {
      themeSwitch = document.querySelector('#theme-switch')
    }

    if (themeSwitch.elements['theme'].value !== theme) {
      themeSwitch.elements['theme'].value = theme
    }
  }

  // Save the theme preference into state
  theme = getThemePreference()
  // Set the `data-theme` attribute early to prevent page flashes
  reflectThemeChange()
</script>

<script webc:bucket="defer">
  /**
   * Saves the theme preference in local storage
   * and updates the DOM to reflect the changes
   */
  function setThemePreference(key = 'theme-preference') {
    localStorage.setItem(key, theme)
    reflectThemeChange()
  }

  // Call once DOM is ready to sync radio buttons with the theme state
  reflectThemeChange()

  // Bind event handler to update the theme on switch interaction
  themeSwitch.addEventListener('change', event => {
    theme = event.target.id
    setThemePreference()
  })

  // Bind event handler to update the theme when `prefers-color-scheme` changes
  window
    .matchMedia('(prefers-color-scheme: light)')
    .addEventListener('change', ({ matches: isLight }) => {
      theme = isLight ? 'light' : 'dark'
      setThemePreference()
    })
</script>

<script webc:bucket="defer">
  /*
    ✨ Progressive Enhancement ✨
    Let's make the switch handle draggable!
  */

  class DraggableSwitch {
    /** @type {HTMLFormElement} switch - The switch element */
    switch
    /** @type {HTMLElement} track - The switch track element */
    track
    /** @type {HTMLElement} handle - The switch handle element */
    handle
    /** @type {boolean} handlePressed - True when the switch handle is pressed */
    handlePressed
    /** @type {number[]} thresholds - Array of pixel offsets of each option relative to the track */
    thresholds
    /** @type {number} min - Alias for the first item in the thresholds array */
    min
    /** @type {number} max - Alias for the last item in the thresholds array */
    max

    /** @param {string} selector */
    constructor(selector) {
      this.switch = document.querySelector(selector)
      this.track = this.switch.querySelector('.track')
      this.handle = this.switch.querySelector('.track svg')
      this.thresholds = [...this.switch.elements['theme']].map(radio => radio.offsetLeft)
      this.min = this.thresholds[0]
      this.max = this.thresholds[this.thresholds.length - 1]

      this.pressHandle = this.pressHandle.bind(this)
      this.dragHandle = this.dragHandle.bind(this)
      this.releaseHandle = this.releaseHandle.bind(this)

      this.track.addEventListener('pointerdown', this.pressHandle)
    }

    /**
     * Returns the number of pixels from the left of the page to the left edge of the element
     * @param {HTMLElement} element
     * @returns {number}
     */
    getOffsetLeft(element) {
      if (!element) return 0
      return this.getOffsetLeft(element.offsetParent) + element.offsetLeft
    }

    /**
     * Returns the x coordinate of the pointer relative to the element
     * @param {number} pageX
     * @param {HTMLElement} element
     * @returns {number}
     */
    getInnerX(clientX, element) {
      return Math.floor(clientX - this.getOffsetLeft(element))
    }

    /**
     * Returns the size of the element including margin in pixels
     * @returns {number}
     */
    getSize(element) {
      const margin = parseInt(getComputedStyle(element).margin)
      return element.clientWidth + (margin * 2)
    }

    /** @param {PointerEvent} event */
    pressHandle(event) {
      this.handlePressed = event.target !== this.track && event.target.type !== 'radio'

      document.addEventListener('pointermove', this.dragHandle)
      document.addEventListener('pointerup', this.releaseHandle, { once: true })
      document.addEventListener('pointercancel', this.releaseHandle, { once: true })
    }

    /** @param {PointerEvent} event */
    dragHandle(event) {
      if (!this.handlePressed) return

      let x = this.getInnerX(event.clientX, this.track)
      let pos = x - (this.getSize(this.handle) / 2)
      if (pos < this.min) pos = this.min
      if (pos > this.max) pos = this.max

      this.handle.style.setProperty('transition-duration', '0s')
      this.handle.style.setProperty('--handle-position', pos + 'px')
    }

    /** @param {PointerEvent} event */
    releaseHandle(event) {
      if (!this.handlePressed) return

      this.handlePressed = false
      this.snapToOption(this.getInnerX(event.clientX, this.track))
      this.handle.removeAttribute('style')

      // Cleanup
      document.removeEventListener('pointermove', this.dragHandle)
      if (event.type === 'pointerup') document.removeEventListener('pointercancel', this.releaseHandle)
      if (event.type === 'pointercancel') document.removeEventListener('pointerup', this.releaseHandle)

    }

    /**
     * Snap the handle to the option closest to the x coordinate
     * @param {number} x
     */
    snapToOption(x) {
      for (let i = this.thresholds.length - 1; i >= 0; i--) {
        if (x > this.thresholds[i] || i === 0) {
          this.switch.elements['theme'][i].click()
          return
        }
      }
    }
  }

  new DraggableSwitch('#theme-switch')
</script>
